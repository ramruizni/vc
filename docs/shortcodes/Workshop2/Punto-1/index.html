<!doctype html><html lang=en dir=ltr>
<head>
<meta charset=utf-8>
<meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="Ray Casting #           &#34;  Es un método sencillo de renderización de modelos de geometría constructiva de sólidos.
Ray casting puede referirse a una variedad de problemas y técnicas:
.El problema general de determinar el primer objeto interceptado por un rayo
.Una técnica para determinación de las caras ocultas (HSR por sus siglas en inglés), también conocida como determinación de las superficies visibles (VSD), basada en buscar la primera intersección de un rayo lanzado desde el observador a través de cada pixel de una imagen.">
<meta name=theme-color content="#FFFFFF">
<meta name=color-scheme content="light dark"><meta property="og:title" content>
<meta property="og:description" content="Ray Casting #           &#34;  Es un método sencillo de renderización de modelos de geometría constructiva de sólidos.
Ray casting puede referirse a una variedad de problemas y técnicas:
.El problema general de determinar el primer objeto interceptado por un rayo
.Una técnica para determinación de las caras ocultas (HSR por sus siglas en inglés), también conocida como determinación de las superficies visibles (VSD), basada en buscar la primera intersección de un rayo lanzado desde el observador a través de cada pixel de una imagen.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://ramruizni.github.io/vc/docs/shortcodes/Workshop2/Punto-1/"><meta property="article:section" content="docs">
<meta property="article:modified_time" content="2021-12-13T08:51:20-05:00">
<title>Punto 1 | Visual Computing</title>
<link rel=manifest href=/vc/manifest.json>
<link rel=icon href=/vc/favicon.png type=image/x-icon>
<link rel=stylesheet href=/vc/book.min.89a77f7e702a8626749b948bbfb01109823daf6c1246ca407d1378833494c402.css integrity="sha256-iad/fnAqhiZ0m5SLv7ARCYI9r2wSRspAfRN4gzSUxAI=" crossorigin=anonymous>
<script defer src=/vc/flexsearch.min.js></script>
<script defer src=/vc/en.search.min.7fa1252e9f8ff8c6d53f640acceebe9708f40d998690ba196182625eb2d9083c.js integrity="sha256-f6ElLp+P+MbVP2QKzO6+lwj0DZmGkLoZYYJiXrLZCDw=" crossorigin=anonymous></script>
</head>
<body dir=ltr>
<input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control>
<main class="container flex">
<aside class=book-menu>
<div class=book-menu-content>
<nav>
<h2 class=book-brand>
<a class="flex align-center" href=/vc/><span>Visual Computing</span>
</a>
</h2>
<div class=book-search>
<input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/>
<div class="book-search-spinner hidden"></div>
<ul id=book-search-results></ul>
</div>
<ul>
<li class=book-section-flat>
<span>Shortcodes</span>
<ul>
<li>
<input type=checkbox id=section-5e90dfc1cda674fda3ec0abb0b45bf6a class=toggle>
<label for=section-5e90dfc1cda674fda3ec0abb0b45bf6a class="flex justify-between">
<a href=https://ramruizni.github.io/vc/docs/shortcodes/team/>Team</a>
</label>
<ul>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/team/dfsolanol/>Dfsolanol</a>
</li>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/team/jcpinedav/>Jcpinedav</a>
</li>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/team/kaninoc/>Kaninoc</a>
</li>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/team/ramruizni/>Ramruizni</a>
</li>
</ul>
</li>
<li>
<input type=checkbox id=section-dea60605fd0f9644cec9b88e08742133 class=toggle checked>
<label for=section-dea60605fd0f9644cec9b88e08742133 class="flex justify-between">
<a href=https://ramruizni.github.io/vc/docs/shortcodes/Workshop2/>Workshop2</a>
</label>
<ul>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/Workshop2/Punto-1/ class=active>Punto 1</a>
</li>
<li>
<a href=https://ramruizni.github.io/vc/docs/shortcodes/Workshop2/Punto-2/>Punto 2</a>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>
<a href=/vc/posts/>
Blog
</a>
</li>
</ul>
</nav>
<script>(function(){var a=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>
</div>
</aside>
<div class=book-page>
<header class=book-header>
<div class="flex align-center justify-between">
<label for=menu-control>
<img src=/vc/svg/menu.svg class=book-icon alt=Menu>
</label>
<strong>Punto 1</strong>
<label for=toc-control>
<img src=/vc/svg/toc.svg class=book-icon alt="Table of Contents">
</label>
</div>
<aside class="hidden clearfix">
<nav id=TableOfContents>
<ul>
<li><a href=#ray-casting>Ray Casting</a></li>
</ul>
</nav>
</aside>
</header>
<article class=markdown><h1 id=ray-casting>
Ray Casting
<a class=anchor href=#ray-casting>#</a>
</h1>
<iframe id=punto1 style=width:420px;height:420px srcdoc="
        <!DOCTYPE html>
        <html>
          <head>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.min.js></script>
            <script src=https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/addons/p5.sound.min.js></script>
            
            
            
            
            
            <script src=../../../../sketches/taller2/punto1.js></script>
          </head>
          <body>
          </body>
        </html>
      "></iframe>
<p>Es un método sencillo de renderización de modelos de geometría constructiva de sólidos.</p>
<p>Ray casting puede referirse a una variedad de problemas y técnicas:</p>
<p>.El problema general de determinar el primer objeto interceptado por un rayo</p>
<p>.Una técnica para determinación de las caras ocultas (HSR por sus siglas en inglés), también conocida como determinación de las superficies visibles (VSD), basada en buscar la primera intersección de un rayo lanzado desde el observador a través de cada pixel de una imagen.</p>
<p>·Un algoritmo no recursivo de renderización ray-tracing que sólo lanza rayos primarios.</p>
<p>·Un método directo de renderización de volúmenes llamado también volume ray casting, en que el rayo es &ldquo;empujado a través&rdquo; del objeto y el campo escalar en 3D de interés es muestreado a lo largo del rayo dentro del objeto. En este método no son expandidos rayos secundarios.</p>
<p>Los rayos geométricos son trazados desde el ojo del observador (trazado hacia atrás) para calcular la radiancia que viaja hacia el observador en la dirección del rayo. La rapidez y simplicidad del trazado de los rayos provienen de computar el color de la luz sin trazar recursivamente rayos adicionales para obtener la radiancia incidente en el punto donde el rayo intercepta. Esto elimina la posibilidad de renderizar con exactitud las reflexiones, refracciones, y las sombras.
Aun así, todos estos elementos pueden ser simulados en un cierto grado, con el uso ingenioso de mapas de textura u otros métodos. La velocidad de cómputo del ray casting lo convirtió en un método práctico de renderizado para los primeros videojuegos de 3D con renderización de escenas en tiempo real.</p>
<p>Fases en el algoritmo de ray casting</p>
<p>Siguiendo la pista de los fotones partiendo del punto de visión hacia los objetos y fuentes de luz, los pasos que ha de dar el algoritmo de ray casting son los siguientes:</p>
<p>Paso 1:
Suponiendo que llegasen fotones al punto de visión siguiendo la trayectoria de un rayo dado, es preciso saber de dónde viene dicha luz, es decir, cuál es su punto de partida o procedencia. Los puntos de procedencia pueden encontrarse en las superficies de los objetos, en las fuentes de luz o ser luz de fondo, es decir, carente de un punto concreto de procedencia.</p>
<p>Paso 2:
En la fase anterior hemos supuesto que llega luz al punto de visión, pero no sabemos si realmente llega. Entonces, para una trayectoria dada, una vez que se conoce el punto de procedencia, se ha de averiguar si existen fotones que recorran el camino del rayo. Si al punto de procedencia llega luz desde de cualquier lugar, cabe la posibilidad de que parte de esa luz alcance también el punto de visión, siguiendo la trayectoria del rayo. Por tanto, es necesario averiguar si llega luz al punto de procedencia y, en caso afirmativo, cuánta llega y de qué color.</p>
<p>Paso 3:
Una vez que se conoce la intensidad y color de la luz que llega al punto de procedencia, la última cuestión que ha de resolver el algoritmo es averiguar qué cantidad de esta luz llega al observador, y cuál es su color.
Necesito determinar si una línea y otra línea se intersectan y cúal es ese punto de intersección. Para esto necesito calcular dos valores T y U. Si T está entre 0 y 1 y U es mayor a 0 las líneas se intersectan.</p>
</article>
<footer class=book-footer>
<div class="flex flex-wrap justify-between">
<div><a class="flex align-center" href=https://github.com/visualcomputing/vc/commit/22787ffaa19f62331a50826df95e6302da8d63cd title="Last modified by jcpinedav | December 13, 2021" target=_blank rel=noopener>
<img src=/vc/svg/calendar.svg class=book-icon alt=Calendar>
<span>December 13, 2021</span>
</a>
</div>
</div>
<script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script>
</footer>
<div class=book-comments>
</div>
<label for=menu-control class="hidden book-menu-overlay"></label>
</div>
<aside class=book-toc>
<div class=book-toc-content>
<nav id=TableOfContents>
<ul>
<li><a href=#ray-casting>Ray Casting</a></li>
</ul>
</nav>
</div>
</aside>
</main>
</body>
</html>